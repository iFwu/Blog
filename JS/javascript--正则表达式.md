正则表达式
--------------
`var expression = / pattern / flags;`

**flags:**每个正则表达式都可带一个或多个标志，用以标明正则表达式的行为

+ g:表示全局模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止。
+ i:表示不区分大小写模式
+ m:表示多行模式，即在到达文本末尾时还会继续查找下一行中是否与模式匹配的项。

###正则表达式中的元字符
>这些元字符在正则表达式都有一种或者多种用途。因此如果想要匹配字符串中包含的这些字符必须转义。下面将描述元字符在模式中的各种应用。

`( [ { \ ^ $ | ) ? * .] }`

|     字符   |     含义     |
|-----------|--------------|
| \t        | 水平制表符    
| \n        | 换行符
| \r        | 回车符
| \f        | 换页符
| \cX       | 与X对应的控制字符（Ctrl+X）
| \v        | 垂直制表符
| \0        | 空字符

####类
>所谓类是指，符合某些特征的对象，是一个泛指，而不是特指某个字符。
使用元字符[ ]构建类。

**1.[ ]:构建简单类**

`[abc]`
![]()

**2.^:与[ ]并用构建反向类**

`[^abc]`
![]()

**3.范围类**
`[a-zA-Z]`

####边界
>单独使用^代表以xxx开头

| 边界元字符 
|----------|------------|
|^         | 以xxx开头   
|$         | 以xxx结尾   
|\b        | 单词边界    
|\B        | 非单词边界  

`^ab`
![]()
`ab$`
![]()

`\ba` ![]()
`a\b` ![]()

####或
>元字符|代表或

`a|c` ![]()

####预定义类

| 字符 |      等价类      |           |
|-----|---------------- |-----------|
|.    | [^\r\n]         | 除了回车符和换行符之外的所有字符
|\d   | [0-9]           | 数字字符
|\D   | [^0-9]          | 非数字字符
|\s   | [\t\n\x0B\f\r]  | 空白符
|\S   | [^\t\n\x0B\f\r] | 非空白符
|\w   | [a-zA-Z_0-9]    | 单词字符，字母、数字下划线
|\W   | [^a-zA-Z_0-9]   | 非单词字符

####分组
>使用元字符( )进行分组

`(ab)` ![]()

**嵌套分组(捕获组):**`(ab(cd))` ![]()
**忽略分组:**有时候我们不希望捕获某些分组，只需要在分组内加上 ?:就可以了，这并不意味着该分组内容不属于正则表达式，只是不会给这个分组加编号了而已
`(ab(?:cd))` ![]()

####量词
>代表出现次数,次数都为正整数

| 量词元字符 
|-------------|-------------------------------|
| ?           | 出现0次或1次      **[0,1]**    
| +           | 至少出现1次       **>=1** 
| *           | 出现0次或多次     **>=0**

**{ }元字符**
{n}   :出现n次        
{n,m} :出现n到m次   
{n,}  :至少出现n次  
{0,m} :最多出现m次    

`a?` ![]()
`a+` ![]()
`a*` ![]()

`a{9}`   ![]()
`a{1,9}` ![]()
`a{0,9}` ![]()

#####贪婪模式与非贪婪模式
>{3,5}到底代表匹配3次，4次还是5次呢？在贪婪模式下会尽可能的多的匹配，也就是说会匹配5次，默认是贪婪模式。而在非贪婪模式下则尽可能少的匹配，也就说会匹配3次，在量词后面加上`?`即可

贪婪模式`'123456789'.replace(/\d{5,8}/g,'O');//"O9"`
非贪婪模式`'123456789'.replace(/\d{5,8}?/g,'O');//"06789"`

####前瞻
|      表达式 |    含义
|------------|--------------------
|exp1(?=exp2)| 匹配后面是exp2的exp1
|exp1(?!exp2)| 匹配后面不是exp2的exp

`good(?=bad)` ![]()
`good(?!bad)` ![]()


###正则表达式实例方法

####exec()
>参数:接收一个参数，即要应用模式的 **字符串**。
>返回:第一个匹配项信息的数组，或者在没有匹配项的情况下返回null。
返回的数组包含两个额外的信息:index和input。index匹配项在字符串中的位置，input表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串(如果模式中没有捕获组，则该数组只包含一项)       

```
var text = 'mom and dad and baby';
var pattern = /mom( and dad)( and baby?)?/g

var matches = pattern.exec(text);

matches// ["mom and dad and baby", " and dad", " and baby"]
matches.index// 0
matches.input// 'mom and dad and baby'

// 忽略分组
var matches = /mom(?: and dad)(?: and baby?)?/g.exec(text)
matches// ["mom and dad and baby"]

var matches = /mom( and dad)(?: and baby?)?/g.exec(text)
matches// ["mom and dad and baby", " and dad"]

var matches = /mom(?: and dad)( and baby?)?/g.exec(text)
matches// ["mom and dad and baby", " and baby"]
```

**Note:**对于`exec()`方法即使在模式中设置了全局标志(g),它每次也只返回一个匹配项。但是在同一个字符串上多次调用`exec()`则会在字符串中查找新匹配项。而在不设置全局标志的情况下，在同一个字符串上多次调用`exe()`，始终返回第一个匹配项信息。

####test()
>参数:接收一个字符串参数
 返回:布尔值
在想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的情况下，使用这个方法非常方便。

```
var text = '000-00-0000';
var pattern = /\d{3}-\d{2}-\d{4}/;

if(pattern.test(text)){
    console.log('The pattern was matched')
} // The pattern was matched
```




```
//分组()->$1分组内匹配
'a1b2c3'.replace(/a(\d)b(\d)c(\d)/g,'a$1-b$2-c$3');//"a1-b2-c3"
'a%1b%2c%3'.replace(/%(\d)%/,'#$1#');//"a#1#b%2%c%3%"

//忽略分组
'a1b2c3'.replace(/a(?:\d)b(?:\d)c(?:\d)/g,'a$1-b$2-c$3');//"a$1-b$2-c$3"

//前瞻
'goodByron'.replace(/good(?=Byron)/g,'T');//"TByron"
'goodByron'.replace(/good(?!Byron)/g,'T');//"goodByron"'
```

**RegExp test()**:测试有没有符合正则表达式的内容 lastIndex:告诉已经搜到哪了，下一次从那开始

```
var reg = /\d+/g;

reg.test('a1b2c3');//true
reg.lastIndex//2
reg.test('a1b2c3');//true
reg.lastIndex;//4
reg.test('a1b2c3');//true
reg.lastIndex//6
reg.test('a1b2c3');//false
reg.lastIndex;//0
```

**exec():**

```
/*非全局调用*/
var reg1 = /\d/;
/*全局调用*/
var reg2 = /\d/g;

reg1.exec('a1b2c3');//["1"]
reg1.exec('a1b2c3');//["1"]
reg2.exec('a1b2c3');//["1"]
reg2.exec('a1b2c3');//["2"]
reg2.exec('a1b2c3');//["3"]
reg2.exec('a1b2c3');//null

while(r=reg.exec('a1b3c3')){
console.log(r.index+':'+r[0])
}//1:1 3:2x 5:3
```

